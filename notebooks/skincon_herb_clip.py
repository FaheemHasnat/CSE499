# -*- coding: utf-8 -*-
"""skincon_herb_clip.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NMl4V9lrWmRdCUtVug77jjeJnBNEysZf

# CLIP-Based Plant Compound to Skin Condition Matching

**Objective**: Use CLIP model to match plant compound descriptions with skin condition images

**Project**: Vision-Language Model (VLM) for predicting plant compound effects on human skin

**Data Sources**:
1. `herb2_final_clean.csv` - Plant compound information (text)
2. `skincon_preprocessed.csv` - Skin condition data with image filenames
3. Skin images: `/content/drive/MyDrive/Skincon/preprocessed/images/`

**Model**: OpenAI CLIP (clip-vit-base-patch32)

**Workflow**:
1. Load datasets and images
2. Encode plant descriptions using CLIP text encoder
3. Encode skin images using CLIP image encoder
4. Compute similarity scores (cosine similarity)
5. Rank and display top-5 plant compounds for each skin image

## 1. Import Required Libraries
"""

# Core data processing libraries
import pandas as pd
import numpy as np
import os
from pathlib import Path
from typing import List, Tuple, Dict
import warnings
warnings.filterwarnings('ignore')

# Image processing
from PIL import Image
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

# Deep learning libraries
import torch
from transformers import CLIPProcessor, CLIPModel
from torch.nn.functional import cosine_similarity

# Progress bar
from tqdm.auto import tqdm

# Google Drive mounting (for Colab)
try:
    from google.colab import drive
    IN_COLAB = True
    print("Running in Google Colab")
except ImportError:
    IN_COLAB = False
    print("Running in local environment")

print(f"\nLibrary versions:")
print(f"  - Pandas: {pd.__version__}")
print(f"  - NumPy: {np.__version__}")
print(f"  - PyTorch: {torch.__version__}")
print(f"  - PIL: {Image.__version__ if hasattr(Image, '__version__') else 'installed'}")

# Check GPU availability
device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"\nUsing device: {device.upper()}")
if device == "cuda":
    print(f"  GPU: {torch.cuda.get_device_name(0)}")
    print(f"  Memory: {torch.cuda.get_device_properties(0).total_memory / 1e9:.1f} GB")

"""## 2. Configure Paths"""

from google.colab import drive
import os
from pathlib import Path

# Mount Google Drive
drive.mount('/content/drive', force_remount=True)

# Base directory
BASE_DIR = "/content/drive/MyDrive/499A Datasets"

#  Correct dataset paths (based on your confirmation)
HERB_FILE = os.path.join(BASE_DIR, "Preprocessed", "herb2_final_clean.csv")
SKINCON_FILE = os.path.join(BASE_DIR, "Skincon", "preprocessed", "skincon_preprocessed.csv")
IMAGE_FOLDER = os.path.join(BASE_DIR, "Skincon", "preprocessed", "images")

# Create embedding and output directories
EMB_SAVE_DIR = os.path.join(BASE_DIR, "Skincon", "preprocessed", "clip_embeddings")
Path(EMB_SAVE_DIR).mkdir(parents=True, exist_ok=True)

OUTPUT_DIR = os.path.join(BASE_DIR, "clip_results")
Path(OUTPUT_DIR).mkdir(parents=True, exist_ok=True)

# Verify all paths
print(" Final Path Configuration Check:")

print(f"Herb CSV: {HERB_FILE} --> Exists: {os.path.exists(HERB_FILE)}")
print(f"Skincon CSV: {SKINCON_FILE} --> Exists: {os.path.exists(SKINCON_FILE)}")
print(f"Image Folder: {IMAGE_FOLDER} --> Exists: {os.path.exists(IMAGE_FOLDER)}")
print(f"Output Directory: {OUTPUT_DIR} --> Exists: {os.path.exists(OUTPUT_DIR)}")

"""## 3. Load Datasets"""

# Load herb dataset
print("Loading plant compound dataset...")
try:
    herb_df = pd.read_csv(HERB_FILE, encoding='utf-8')
    print(f" Loaded herb dataset: {herb_df.shape[0]:,} rows x {herb_df.shape[1]} columns")

    # Filter for SKIN-RELATED diseases ONLY
    if 'MeSH_disease_class' in herb_df.columns:
        print("\n Filtering for SKIN-RELATED diseases only...")
        herb_df = herb_df[
            herb_df['MeSH_disease_class'].str.contains('Skin and Connective Tissue Diseases',
                                                       case=False, na=False)
        ].copy()
        print(f"   After skin filter: {herb_df.shape[0]:,} rows (skin diseases only)")

except Exception as e:
    print(f" Error loading herb dataset: {e}")
    herb_df = None

# Load skincon dataset
print("\nLoading skin condition dataset...")
try:
    skincon_df = pd.read_csv(SKINCON_FILE, encoding='utf-8')
    print(f" Loaded skincon dataset: {skincon_df.shape[0]:,} rows x {skincon_df.shape[1]} columns")
except Exception as e:
    print(f" Error loading skincon dataset: {e}")
    skincon_df = None

# Merge datasets on Disease_name == label (SKIN DISEASES ONLY)
if herb_df is not None and skincon_df is not None:

    print(" MERGING HERB & SKINCON DATASETS (SKIN DISEASES ONLY)")


    # Normalize for matching
    herb_df['disease_norm'] = herb_df['Disease_name'].str.lower().str.strip()
    skincon_df['label_norm'] = skincon_df['label'].str.lower().str.strip()

    # Show unique skin diseases available
    skin_diseases = herb_df['Disease_name'].nunique()
    print(f" Unique SKIN diseases in herb dataset: {skin_diseases}")
    print(f" Unique labels in skincon dataset: {skincon_df['label'].nunique()}")

    # Merge
    matched_df = skincon_df.merge(
        herb_df[['Disease_name', 'Disease_alias_name', 'Herb_en_name', 'Function',
                 'MeSH_disease_class', 'disease_norm']],
        left_on='label_norm',
        right_on='disease_norm',
        how='inner'
    )

    # Rename columns
    matched_df.rename(columns={
        'Herb_en_name': 'Herb_Name',
        'Function': 'Herb_Function',
        'Disease_name': 'Disease_Name',
        'Disease_alias_name': 'Disease_Alias_Name'
    }, inplace=True)

    # Clean up temp columns
    matched_df.drop(columns=['disease_norm', 'label_norm'], inplace=True)

    print(f"\n Match Results (SKIN DISEASES ONLY):")
    print(f"   Original skincon rows: {skincon_df.shape[0]:,}")
    print(f"   Matched rows: {matched_df.shape[0]:,}")
    print(f"   Match rate: {(matched_df.shape[0] / skincon_df.shape[0] * 100):.1f}%")

    if matched_df.shape[0] > 0:
        # Save merged dataset
        matched_csv = os.path.join(BASE_DIR, "skincon_herb_matched_SKIN_ONLY.csv")
        matched_df.to_csv(matched_csv, index=False, encoding='utf-8')
        print(f"\n Saved to: skincon_herb_matched_SKIN_ONLY.csv")

        # Show matched skin diseases
        matched_diseases = matched_df['Disease_Name'].nunique()
        print(f"\n Matched {matched_diseases} unique SKIN diseases")
        print(f"   Examples: {', '.join(matched_df['Disease_Name'].unique()[:5])}")

        # Show new columns
        print(f"\n New Columns:")
        print(f"   â€¢ Herb_Name: {matched_df['Herb_Name'].notna().sum():,} values")
        print(f"   â€¢ Herb_Function: {matched_df['Herb_Function'].notna().sum():,} values")
        print(f"   â€¢ Disease_Name: {matched_df['Disease_Name'].notna().sum():,} values")
        print(f"   â€¢ Disease_Alias_Name: {matched_df['Disease_Alias_Name'].notna().sum():,} values")
        print(f"   â€¢ MeSH_disease_class: All contain 'Skin and Connective Tissue Diseases'")

        # Use matched data going forward
        skincon_df = matched_df.copy()
    else:
        print("\n WARNING: No matches found! Check disease name alignment.")
        skincon_df = None

else:
    print("\n Failed to load datasets")

"""## 4. Explore Datasets"""

if herb_df is not None:
    print("HERB DATASET PREVIEW")
    print("=" * 80)
    display(herb_df.head())

if skincon_df is not None:
    print("SKINCON DATASET PREVIEW")

    display(skincon_df.head())

# Preview matched dataset with herb information
if 'Herb_Name' in skincon_df.columns:

    print(" MATCHED DATASET - Skin Conditions with Herb Info")


    display_cols = ['label', 'Herb_Name', 'Herb_Function', 'Disease_Name', 'Disease_Alias_Name']
    available_cols = [c for c in display_cols if c in skincon_df.columns]

    display(skincon_df[available_cols].head(10))

"""## 5. Prepare Text Descriptions for Plant Compounds"""

def create_herb_description(row):
    """
    Create enhanced description using matched herb information.
    """
    parts = []

    # Use matched Herb_Name
    if 'Herb_Name' in row and pd.notna(row['Herb_Name']):
        parts.append(f"Herb: {row['Herb_Name']}")

    # Use matched Herb_Function
    if 'Herb_Function' in row and pd.notna(row['Herb_Function']):
        func = str(row['Herb_Function'])[:200]
        parts.append(f"Function: {func}")

    # Add disease treatment info
    if 'Disease_Name' in row and pd.notna(row['Disease_Name']):
        parts.append(f"Treats: {row['Disease_Name']}")

    # Add aliases
    if 'Disease_Alias_Name' in row and pd.notna(row['Disease_Alias_Name']):
        alias = str(row['Disease_Alias_Name'])[:100]
        parts.append(f"Also: {alias}")

    return ". ".join(parts) if parts else "Medicinal herb for skin treatment"

if skincon_df is not None and 'Herb_Name' in skincon_df.columns:
    print("Creating herb-based descriptions...")
    skincon_df['herb_description'] = skincon_df.apply(create_herb_description, axis=1)

    print(f" Created {len(skincon_df):,} descriptions")
    print(f"\n Samples:")
    for i, desc in enumerate(skincon_df['herb_description'].head(3), 1):
        print(f"\n{i}. {desc[:180]}..." if len(desc) > 180 else f"\n{i}. {desc}")

"""## 6. Verify Image Files"""

import glob

if skincon_df is not None and os.path.exists(IMAGE_FOLDER):
    print("Verifying image files (including subfolders)...")


    # Try to find image filename column
    image_col = None
    for col in ['image_filename', 'filename', 'image_name', 'file', 'image']:
        if col in skincon_df.columns:
            image_col = col
            break

    if image_col is None:
        print(f"Could not find image filename column.")
        print(f"  Available columns: {', '.join(skincon_df.columns.tolist())}")
    else:
        print(f"Using image filename column: '{image_col}'")

        # Create a dictionary mapping filenames â†’ full paths (recursive search)
        print("\nScanning all image files recursively...")
        image_paths = glob.glob(os.path.join(IMAGE_FOLDER, "**", "*.*"), recursive=True)
        image_map = {os.path.basename(p): p for p in image_paths}

        print(f"  Found {len(image_paths):,} total image files in subfolders.\n")

        # Map filenames from dataset to full paths
        skincon_df['image_path'] = skincon_df[image_col].apply(
            lambda x: image_map.get(str(x).strip()) if pd.notna(x) else None
        )

        # Check which images exist
        skincon_df['image_exists'] = skincon_df['image_path'].notnull()
        existing_images = skincon_df['image_exists'].sum()
        total_images = len(skincon_df)

        print(f"Found {existing_images:,} / {total_images:,} images")
        print(f"  Missing: {total_images - existing_images:,} images")

        if existing_images > 0:
            skincon_df = skincon_df[skincon_df['image_exists']].copy()
            print(f"\n Dataset filtered to {len(skincon_df):,} rows with existing images")
        else:
            print(f"\n No matching images found in any subfolders under {IMAGE_FOLDER}")
else:
    if skincon_df is None:
        print("Skincon dataset not loaded")
    else:
        print(f"Image folder not found: {IMAGE_FOLDER}")

"""## 7. Load CLIP Model"""

MODEL_NAME = "openai/clip-vit-base-patch32"

print(f"Loading CLIP model: {MODEL_NAME}")


try:
    model = CLIPModel.from_pretrained(MODEL_NAME)
    processor = CLIPProcessor.from_pretrained(MODEL_NAME)

    model = model.to(device)
    model.eval()

    print(f"CLIP model loaded successfully on {device.upper()}")
    print(f"\nModel details:")
    print(f"  - Vision encoder: {model.config.vision_config.hidden_size}-dim embeddings")
    print(f"  - Text encoder: {model.config.text_config.hidden_size}-dim embeddings")

except Exception as e:
    print(f"Error loading CLIP model: {e}")
    model = None
    processor = None

"""## 8. Encode Plant Compound Descriptions"""

def encode_texts(texts: List[str], batch_size: int = 32) -> torch.Tensor:
    """
    Encode text descriptions into CLIP embeddings.
    """
    all_embeddings = []

    with torch.no_grad():
        for i in tqdm(range(0, len(texts), batch_size), desc="Encoding texts"):
            batch_texts = texts[i:i+batch_size]

            inputs = processor(text=batch_texts, return_tensors="pt",
                             padding=True, truncation=True, max_length=77)
            inputs = {k: v.to(device) for k, v in inputs.items()}

            text_embeddings = model.get_text_features(**inputs)
            text_embeddings = text_embeddings / text_embeddings.norm(dim=-1, keepdim=True)

            all_embeddings.append(text_embeddings.cpu())

    return torch.cat(all_embeddings, dim=0)

# Encode herb descriptions (SKIN diseases only)
if skincon_df is not None and model is not None and 'herb_description' in skincon_df.columns:
    print("Encoding herb-based descriptions with CLIP (SKIN diseases)...")


    herb_texts = skincon_df['herb_description'].tolist()
    herb_embeddings = encode_texts(herb_texts, batch_size=32)

    print(f"\n Encoded {len(herb_embeddings):,} herb descriptions")
    print(f"  Embedding shape: {herb_embeddings.shape}")
    print(f"  All descriptions are for SKIN-related treatments")
else:
    print("âœ— Cannot encode: missing herb_description column or model not loaded")
    herb_embeddings = None

import os

dataset_dir = "/content/drive/MyDrive/499A Datasets/Skincon/preprocessed/images"

# Verify folder existence and count files
print("Folder exists:", os.path.exists(dataset_dir))
print("Total files:", len(os.listdir(dataset_dir)))

# Show a few sample file names
print("First few files:", os.listdir(dataset_dir)[:5])

import os
from sklearn.model_selection import train_test_split

dataset_dir = "/content/drive/MyDrive/499A Datasets/Skincon/preprocessed/images"

# Recursively find all image files inside all subfolders
all_images = []
for root, dirs, files in os.walk(dataset_dir):
    for file in files:
        if file.lower().endswith(('.png', '.jpg', '.jpeg')):
            all_images.append(os.path.join(root, file))

print(f" Found {len(all_images)} image files in total.")

# Split into 70% train and 30% test
train_imgs, test_imgs = train_test_split(all_images, test_size=0.3, random_state=42)

print(f"Train images: {len(train_imgs)}")
print(f"Test images: {len(test_imgs)}")

"""## 9. Encode Skin Condition Images"""

def encode_images(image_paths: List[str], batch_size: int = 16) -> Tuple[torch.Tensor, List[int]]:
    """
    Encode images into CLIP embeddings.
    """
    all_embeddings = []
    valid_indices = []

    with torch.no_grad():
        for i in tqdm(range(0, len(image_paths), batch_size), desc="Encoding images"):
            batch_paths = image_paths[i:i+batch_size]
            batch_images = []
            batch_valid_idx = []

            for idx, path in enumerate(batch_paths):
                try:
                    if path and os.path.exists(path):
                        image = Image.open(path).convert('RGB')
                        batch_images.append(image)
                        batch_valid_idx.append(i + idx)
                except Exception as e:
                    print(f"Warning: Could not load image {path}: {e}")
                    continue

            if batch_images:
                inputs = processor(images=batch_images, return_tensors="pt", padding=True)
                inputs = {k: v.to(device) for k, v in inputs.items()}

                image_embeddings = model.get_image_features(**inputs)
                image_embeddings = image_embeddings / image_embeddings.norm(dim=-1, keepdim=True)

                all_embeddings.append(image_embeddings.cpu())
                valid_indices.extend(batch_valid_idx)

    if all_embeddings:
        return torch.cat(all_embeddings, dim=0), valid_indices
    else:
        return torch.empty(0), []

if skincon_df is not None and model is not None and 'image_path' in skincon_df.columns:
    print("Encoding skin condition images with CLIP...")
    print("=" * 80)

    image_paths = skincon_df['image_path'].tolist()
    image_embeddings, valid_indices = encode_images(image_paths, batch_size=16)

    skincon_df = skincon_df.iloc[valid_indices].reset_index(drop=True)

    print(f"\nEncoded {len(image_embeddings):,} skin images")
    print(f"  Embedding shape: {image_embeddings.shape}")
else:
    print("Cannot encode images: skincon_df, model, or image_path not available")
    image_embeddings = None

"""## 10. Compute Similarity Scores"""

if image_embeddings is not None and herb_embeddings is not None:
    print("Computing similarity scores...")
    print("=" * 80)

    similarity_matrix = image_embeddings @ herb_embeddings.T

    print(f"Computed similarity matrix")
    print(f"  Shape: {similarity_matrix.shape} (images x plant compounds)")
    print(f"  Min similarity: {similarity_matrix.min():.4f}")
    print(f"  Max similarity: {similarity_matrix.max():.4f}")
    print(f"  Mean similarity: {similarity_matrix.mean():.4f}")
else:
    print("Cannot compute similarity: embeddings not available")
    similarity_matrix = None

"""## 11. Get Top-5 Plant Compounds for Each Image"""

if similarity_matrix is not None:
    print("Finding top-5 plant compounds for each image...")
    print("=" * 80)

    top_k = 5
    top_scores, top_indices = torch.topk(similarity_matrix, k=top_k, dim=1)

    print(f"Found top-{top_k} matches for {len(top_scores):,} images")
else:
    print("Cannot find top matches: similarity matrix not available")
    top_scores = None
    top_indices = None

"""## 12. Display Results"""

if top_scores is not None and top_indices is not None and skincon_df is not None:
    print("="*80)
    print(" TOP-5 HERB MATCHES FOR SKIN CONDITIONS (SKIN DISEASES ONLY)")
    print("="*80)

    num_to_display = min(5, len(skincon_df))

    for img_idx in range(num_to_display):
        row = skincon_df.iloc[img_idx]

        print(f"  Image #{img_idx + 1}: {row['label']}")
        print(f" File: {os.path.basename(row['image_path'])}")
        if 'Disease_Name' in row:
            print(f" Skin Disease: {row['Disease_Name']}")
        print(f"{'='*80}")

        for rank, (score, herb_idx) in enumerate(zip(top_scores[img_idx], top_indices[img_idx]), 1):
            matched_row = skincon_df.iloc[herb_idx.item()]

            herb_name = matched_row.get('Herb_Name', 'Unknown')
            herb_func = matched_row.get('Herb_Function', 'N/A')
            disease = matched_row.get('Disease_Name', 'N/A')

            print(f"\n  {rank}.  {herb_name}")
            print(f"      Similarity: {score.item():.4f}")
            print(f"      Function: {str(herb_func)[:100]}{'...' if len(str(herb_func)) > 100 else ''}")
            print(f"      Treats: {disease}")

    if len(skincon_df) > num_to_display:
        print(f"\n... and {len(skincon_df) - num_to_display} more skin condition images")
else:
    print(" Cannot display results - missing required data")

"""## 13. Save Results to CSV"""

if top_scores is not None and top_indices is not None and skincon_df is not None:
    print("Saving enhanced results to CSV (SKIN diseases only)...")
    print("="*80)

    results = []

    for img_idx in range(len(skincon_df)):
        img_row = skincon_df.iloc[img_idx]

        for rank, (score, herb_idx) in enumerate(zip(top_scores[img_idx], top_indices[img_idx]), 1):
            match_row = skincon_df.iloc[herb_idx.item()]

            results.append({
                'image_filename': os.path.basename(img_row['image_path']),
                'skin_condition_label': img_row['label'],
                'rank': rank,
                'similarity_score': score.item(),
                'herb_name': match_row.get('Herb_Name', 'Unknown'),
                'herb_function': match_row.get('Herb_Function', ''),
                'disease_name': match_row.get('Disease_Name', ''),
                'disease_alias': match_row.get('Disease_Alias_Name', ''),
                'full_description': match_row.get('herb_description', ''),
                'disease_class': 'Skin and Connective Tissue Diseases'
            })

    results_df = pd.DataFrame(results)
    output_file = os.path.join(OUTPUT_DIR, 'skincon_herb_clip_results_SKIN_ONLY.csv')
    results_df.to_csv(output_file, index=False, encoding='utf-8')

    print(f"âœ“ Saved to: skincon_herb_clip_results_SKIN_ONLY.csv")
    print(f"  Total predictions: {len(results_df):,} rows")
    print(f"  Skin images processed: {len(skincon_df):,}")
    print(f"  Top-K per image: 5")
    print(f"  All treatments are for SKIN diseases ONLY")
else:
    print("âœ— Cannot save results - missing required data")

"""## 14. Visualize Sample Prediction"""

def visualize_prediction(image_idx: int):
    """
    Visualize skin image with matched herb info (SKIN diseases only).
    """
    if image_idx >= len(skincon_df):
        print(f"âœ— Invalid index: {image_idx}")
        return

    row = skincon_df.iloc[image_idx]

    try:
        image = Image.open(row['image_path']).convert('RGB')
    except Exception as e:
        print(f"âœ— Error loading image: {e}")
        return

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 8))

    # Display image
    ax1.imshow(image)
    ax1.axis('off')
    ax1.set_title(f"Skin Condition: {row['label']}\n{os.path.basename(row['image_path'])}",
                 fontsize=14, fontweight='bold')

    # Display herb information
    ax2.axis('off')
    y = 0.95

    ax2.text(0.5, y, f"ðŸŒ¿ Matched Herb Treatment (SKIN DISEASE)",
            fontsize=16, fontweight='bold', ha='center', color='darkgreen')
    y -= 0.10

    ax2.text(0.05, y, f"Herb Name:", fontsize=12, fontweight='bold')
    y -= 0.05
    ax2.text(0.05, y, row.get('Herb_Name', 'Unknown'), fontsize=11, color='darkblue')
    y -= 0.08

    ax2.text(0.05, y, f"Skin Disease Treated:", fontsize=12, fontweight='bold')
    y -= 0.05
    ax2.text(0.05, y, row.get('Disease_Name', 'Unknown'), fontsize=11, color='darkred')
    y -= 0.08

    if pd.notna(row.get('Disease_Alias_Name')):
        ax2.text(0.05, y, f"Also Known As:", fontsize=12, fontweight='bold')
        y -= 0.05
        aliases = str(row['Disease_Alias_Name'])[:120]
        ax2.text(0.05, y, aliases, fontsize=10, color='gray', wrap=True)
        y -= 0.10

    ax2.text(0.05, y, f"Herb Function:", fontsize=12, fontweight='bold')
    y -= 0.05
    function = str(row.get('Herb_Function', 'Not available'))[:250]
    ax2.text(0.05, y, function, fontsize=10, wrap=True, color='black')
    y -= 0.12

    ax2.text(0.05, y, f"Disease Class: Skin and Connective Tissue Diseases",
            fontsize=9, style='italic', color='green')

    plt.tight_layout()

    output_path = os.path.join(OUTPUT_DIR, f'skin_herb_match_{image_idx}.png')
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    print(f"âœ“ Visualization saved: {output_path}")
    plt.show()

# Visualize first matched result
if skincon_df is not None and len(skincon_df) > 0:
    print("Creating visualization for herb-skin match (SKIN disease)...")
    print("="*80)
    visualize_prediction(0)
else:
    print("âœ— Cannot visualize - no matched data available")

"""## 15. Summary Statistics"""

if similarity_matrix is not None and top_scores is not None:

    print(" SUMMARY STATISTICS (SKIN DISEASES ONLY)")


    print(f"\n Datasets:")
    print(f"  - Plant compounds (SKIN diseases): {len(skincon_df):,}")
    print(f"  - Skin images processed: {len(skincon_df):,}")
    print(f"  - Total similarity computations: {len(skincon_df) * len(skincon_df):,}")
    print(f"  - Disease filter: 'Skin and Connective Tissue Diseases' ONLY")

    print(f"\n Similarity Scores:")
    print(f"  - Overall mean: {similarity_matrix.mean():.4f}")
    print(f"  - Overall std: {similarity_matrix.std():.4f}")
    print(f"  - Overall min: {similarity_matrix.min():.4f}")
    print(f"  - Overall max: {similarity_matrix.max():.4f}")

    print(f"\n Top-5 Matches:")
    print(f"  - Mean similarity of top-1 matches: {top_scores[:, 0].mean():.4f}")
    print(f"  - Mean similarity of top-5 matches: {top_scores[:, 4].mean():.4f}")
    print(f"  - Best match overall: {top_scores.max():.4f}")

    if 'Disease_Name' in skincon_df.columns:
        unique_diseases = skincon_df['Disease_Name'].nunique()
        print(f"\n Disease Statistics:")
        print(f"  - Unique SKIN diseases matched: {unique_diseases}")
        print(f"  - Top 5 diseases: {', '.join(skincon_df['Disease_Name'].value_counts().head().index.tolist())}")


    print(" CLIP MATCHING PIPELINE COMPLETED SUCCESSFULLY!")

else:
    print(" Cannot display summary - results not available")